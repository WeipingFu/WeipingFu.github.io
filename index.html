<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">






  
  
  <link rel="stylesheet" media="all" href="/lib/Han/dist/han.min.css?v=3.3">




<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.2" />






<meta name="description" content="知识记录">
<meta property="og:type" content="website">
<meta property="og:title" content="fwp个人博客">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="fwp个人博客">
<meta property="og:description" content="知识记录">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="fwp个人博客">
<meta name="twitter:description" content="知识记录">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>fwp个人博客</title>
  














</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">fwp个人博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/07/10/js模块化小结/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="fwp">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="fwp个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/07/10/js模块化小结/" itemprop="url">js模块化小结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-07-10T22:10:24+08:00">
                2017-07-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/javascript/" itemprop="url" rel="index">
                    <span itemprop="name">javascript</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/07/10/js模块化小结/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2017/07/10/js模块化小结/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
             <span id="/2017/07/10/js模块化小结/" class="leancloud_visitors" data-flag-title="js模块化小结">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body han-init-context" itemprop="articleBody">

      
      

      
        
          
            <h3 id="一、模块与组件的区别"><a href="#一、模块与组件的区别" class="headerlink" title="一、模块与组件的区别"></a>一、模块与组件的区别</h3><h4 id="1-模块"><a href="#1-模块" class="headerlink" title="1. 模块"></a>1. 模块</h4><p>模块通常指的是实现某个特定功能的js模块，如一个实现时间格式化的js文件。<br>把多个功能实现放在一个js文件中，随着需要实现的功能越来越多，js文件也越来越复杂，不利于开发与维护，所以要把js文件进行功能拆分，形成多个实现特定功能的js文件，这就是模块。</p>
<h4 id="2-组件"><a href="#2-组件" class="headerlink" title="2. 组件"></a>2. 组件</h4><p>组件比模块更大的概念，一个组件通常包括html模板、css样式和js三部分。通常我们可以将一个页面拆分成多个组件，一个组件可以引入多个js模块，组件可以为多个页面所复用。</p>
<h3 id="二、使用模块化开发的好处"><a href="#二、使用模块化开发的好处" class="headerlink" title="二、使用模块化开发的好处"></a>二、使用模块化开发的好处</h3><p>1）解决命名冲突问题（也可以通过命名空间来缓解，但是代码会变繁琐）<br>2）避免过多的文件依赖（文件依赖：使用某个js文件前必须引入其他文件）<br>3）模块版本管理，通过配置结合构建工具，可以轻松实现模块的版本管理。<br>4）提高代码的可维护性<br>5）前端性能优化（可实现异步加载模块）<br>6）跨环境共享模块（可实现模块的跨服务器和浏览器共享）</p>
<h3 id="三、几个主要的模块化规范"><a href="#三、几个主要的模块化规范" class="headerlink" title="三、几个主要的模块化规范"></a>三、几个主要的模块化规范</h3><h4 id="1-CommonJS"><a href="#1-CommonJS" class="headerlink" title="1. CommonJS"></a>1. CommonJS</h4><h4 id="2"><a href="#2" class="headerlink" title="2."></a>2.</h4>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/06/21/react组件生命周期/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="fwp">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="fwp个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/06/21/react组件生命周期/" itemprop="url">react组件生命周期</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-06-21T21:30:31+08:00">
                2017-06-21
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/react/" itemprop="url" rel="index">
                    <span itemprop="name">react</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/06/21/react组件生命周期/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2017/06/21/react组件生命周期/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
             <span id="/2017/06/21/react组件生命周期/" class="leancloud_visitors" data-flag-title="react组件生命周期">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body han-init-context" itemprop="articleBody">

      
      

      
        
          
            <h3 id="实例化"><a href="#实例化" class="headerlink" title="实例化"></a>实例化</h3><h4 id="首次实例化"><a href="#首次实例化" class="headerlink" title="首次实例化"></a>首次实例化</h4><ul>
<li>getDefaultProps</li>
<li>getInitialState</li>
<li>componentWillMount</li>
<li>render</li>
<li>componentDidMount</li>
</ul>
<h4 id="实例化完成后的更新"><a href="#实例化完成后的更新" class="headerlink" title="实例化完成后的更新"></a>实例化完成后的更新</h4><ul>
<li>getInitialState </li>
<li>componentWillMount </li>
<li>render </li>
<li>componentDidMount</li>
</ul>
<h3 id="存在期"><a href="#存在期" class="headerlink" title="存在期"></a>存在期</h3><h4 id="组件已存在时的状态改变"><a href="#组件已存在时的状态改变" class="headerlink" title="组件已存在时的状态改变"></a>组件已存在时的状态改变</h4><ul>
<li>componentWillReceiveProps </li>
<li>shouldComponentUpdate </li>
<li>componentWillUpdate</li>
<li>render </li>
<li>componentDidUpdate</li>
</ul>
<h4 id="销毁-amp-清理期"><a href="#销毁-amp-清理期" class="headerlink" title="销毁&amp;清理期"></a>销毁&amp;清理期</h4><p>componentWillUnmount</p>
<h3 id="生命周期共提供了10个不同的API"><a href="#生命周期共提供了10个不同的API" class="headerlink" title="生命周期共提供了10个不同的API"></a>生命周期共提供了10个不同的API</h3><h4 id="1-getDefaultProps"><a href="#1-getDefaultProps" class="headerlink" title="1.getDefaultProps"></a>1.getDefaultProps</h4><p>作用于组件类，只调用一次，返回对象用于设置默认的props，对于引用值，会在实例中共享。</p>
<h4 id="2-getInitialState"><a href="#2-getInitialState" class="headerlink" title="2.getInitialState"></a>2.getInitialState</h4><p>作用于组件的实例，在实例创建时调用一次，用于初始化每个实例的state，此时可以访问this.props。</p>
<h4 id="3-componentWillMount"><a href="#3-componentWillMount" class="headerlink" title="3.componentWillMount"></a>3.componentWillMount</h4><p>在完成首次渲染之前调用，此时仍可以修改组件的state。</p>
<h4 id="4-render"><a href="#4-render" class="headerlink" title="4.render"></a>4.render</h4><p>必选的方法，创建虚拟DOM，该方法具有特殊的规则：<br>1）只能通过this.props和this.state访问数据<br>2）可以返回null、false或任何React组件<br>3）只能出现一个顶级组件（不能返回数组）<br>4）不能改变组件的状态<br>5）不能修改DOM的输出</p>
<h4 id="5-componentDidMount"><a href="#5-componentDidMount" class="headerlink" title="5.componentDidMount"></a>5.componentDidMount</h4><p>真实的DOM被渲染出来后调用，在该方法中可通过this.getDOMNode()访问到真实的DOM元素。此时已可以使用其他类库来操作这个DOM。</p>
<p>在服务端中，该方法不会被调用。</p>
<h4 id="6-componentWillReceiveProps"><a href="#6-componentWillReceiveProps" class="headerlink" title="6.componentWillReceiveProps"></a>6.componentWillReceiveProps</h4><p>组件接收到新的props时调用，并将其作为参数nextProps使用，此时可以更改组件props及state。</p>
<pre><code>componentWillReceiveProps: function(nextProps) {
    if (nextProps.bool) {
        this.setState({
            bool: true
        });
    }
}
</code></pre><h4 id="7-shouldComponentUpdate"><a href="#7-shouldComponentUpdate" class="headerlink" title="7.shouldComponentUpdate"></a>7.shouldComponentUpdate</h4><p>组件是否应当渲染新的props或state，返回false表示跳过后续的生命周期方法，通常不需要使用以避免出现bug。在出现应用的瓶颈时，可通过该方法进行适当的优化。</p>
<p>在首次渲染期间或者调用了forceUpdate方法后，该方法不会被调用</p>
<h4 id="8-componentWillUpdate"><a href="#8-componentWillUpdate" class="headerlink" title="8.componentWillUpdate"></a>8.componentWillUpdate</h4><p>接收到新的props或者state后，进行渲染之前调用，此时不允许更新props或state。</p>
<h4 id="9-componentDidUpdate"><a href="#9-componentDidUpdate" class="headerlink" title="9.componentDidUpdate"></a>9.componentDidUpdate</h4><p>完成渲染新的props或者state后调用，此时可以访问到新的DOM元素。</p>
<h4 id="10-componentWillUnmount"><a href="#10-componentWillUnmount" class="headerlink" title="10.componentWillUnmount"></a>10.componentWillUnmount</h4><p>组件被移除之前被调用，可以用于做一些清理工作，在componentDidMount方法中添加的所有任务都需要在该方法中撤销，比如创建的定时器或添加的事件监听器。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/06/20/react 子组件使用props(一）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="fwp">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="fwp个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/06/20/react 子组件使用props(一）/" itemprop="url">react子组件使用props（一）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-06-20T20:20:11+08:00">
                2017-06-20
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/react/" itemprop="url" rel="index">
                    <span itemprop="name">react</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/06/20/react 子组件使用props(一）/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2017/06/20/react 子组件使用props(一）/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
             <span id="/2017/06/20/react 子组件使用props(一）/" class="leancloud_visitors" data-flag-title="react子组件使用props（一）">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body han-init-context" itemprop="articleBody">

      
      

      
        
          
            <p>子组件显示父组件穿过来的props有两种方式：</p>
<p><strong>1、直接使用</strong><br>这种方式，父组件改变props后，子组件重新渲染，由于直接使用的props，所以我们不需要做什么就可以正常显示最新的props</p>
<pre><code>class Child extends Component {
    render() {
        return &lt;div&gt;{this.props.someThings}&lt;/div&gt;
    }
}
</code></pre><p><strong>2、转换成自己的state</strong><br>这种方式，由于我们使用的是state，所以每当父组件每次重新传递props时，我们需要重新处理下，将props转换成自己的state，这里就用到了 componentWillReceiveProps。</p>
<p>每次子组件接收到新的props，都会重新渲染一次，除非你做了处理来阻止（比如使用：shouldComponentUpdate），但是你可以在这次渲染前，根据新的props更新state，更新state也会触发一次重新渲染，但react不会这么傻，所以只会渲染一次，这对应用的性能是有利的。</p>
<pre><code>class Child extends Component {
    constructor(props) {
        super(props);
        this.state = {
            someThings: props.someThings
        };
    }
    componentWillReceiveProps(nextProps) {
        this.setState({someThings: nextProps.someThings});
    }
    render() {
        return &lt;div&gt;{this.state.someThings}&lt;/div&gt;
    }
}
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/05/25/网络-HTTP协议/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="fwp">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="fwp个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/05/25/网络-HTTP协议/" itemprop="url">http协议</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-05-25T17:50:21+08:00">
                2017-05-25
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/网络/" itemprop="url" rel="index">
                    <span itemprop="name">网络</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/05/25/网络-HTTP协议/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2017/05/25/网络-HTTP协议/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
             <span id="/2017/05/25/网络-HTTP协议/" class="leancloud_visitors" data-flag-title="http协议">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body han-init-context" itemprop="articleBody">

      
      

      
        
          
            <h2 id="HTTP协议简介"><a href="#HTTP协议简介" class="headerlink" title="HTTP协议简介"></a>HTTP协议简介</h2><p>HyperText Transfer Protocol 超文本传输协议<br>HTTP是一个基于TCP/IP通信协议来传递数据（HTML 文件, 图片文件, 查询结果等）。<br>HTTP是一个属于应用层的面向对象的协议，由于其简捷、快速的方式，适用于分布式超媒体信息系统。<br>HTTP协议工作于客户端-服务端架构为上。浏览器作为HTTP客户端通过URL向HTTP服务端即WEB服务器发送所有请求。Web服务器根据接收到的请求后，向客户端发送响应信息。</p>
<p>HTTP使用统一资源标识符（Uniform Resource Identifiers, URI）来传输数据和建立连接。URL是一种特殊类型的URI，包含了用于查找某个资源的足够的信息</p>
<h2 id="URL地址分析"><a href="#URL地址分析" class="headerlink" title="URL地址分析"></a>URL地址分析</h2><p>URL,全称是UniformResourceLocator, 中文叫统一资源定位符,是互联网上用来标识某一处资源的地址。以下面这个URL为例，介绍下普通URL的各部分组成：</p>
<p><a href="http://www.aspxfans.com:8080/news/index.asp?boardID=5&amp;ID=24618&amp;page=1#name" target="_blank" rel="external">http://www.aspxfans.com:8080/news/index.asp?boardID=5&amp;ID=24618&amp;page=1#name</a></p>
<blockquote>
<p>从上面的URL可以看出，一个完整的URL包括以下几部分：<br><strong>1.协议部分</strong>：该URL的协议部分为“http：”，这代表网页使用的是HTTP协议。在Internet中可以使用多种协议，如HTTP，FTP等等本例中使用的是HTTP协议。在”HTTP”后面的“//”为分隔符<br><strong>2.域名部分</strong>：该URL的域名部分为“www.aspxfans.com”。一个URL中，也可以使用IP地址作为域名使用<br><strong>3.端口部分</strong>：跟在域名后面的是端口，域名和端口之间使用“:”作为分隔符。端口不是一个URL必须的部分，如果省略端口部分，将采用默认端口<br><strong>4.虚拟目录部分</strong>：从域名后的第一个“/”开始到最后一个“/”为止，是虚拟目录部分。虚拟目录也不是一个URL必须的部分。本例中的虚拟目录是“/news/”<br><strong>5.文件名部分</strong>：从域名后的最后一个“/”开始到“？”为止，是文件名部分，如果没有“?”,则是从域名后的最后一个“/”开始到“#”为止，是文件部分，如果没有“？”和“#”，那么从域名后的最后一个“/”开始到结束，都是文件名部分。本例中的文件名是“index.asp”。文件名部分也不是一个URL必须的部分，如果省略该部分，则使用默认的文件名<br><strong>6.锚部分</strong>：从“#”开始到最后，都是锚部分。本例中的锚部分是“name”。锚部分也不是一个URL必须的部分<br><strong>7.参数部分</strong>：从“？”开始到“#”为止之间的部分为参数部分，又称搜索部分、查询部分。本例中的参数部分为“boardID=5&amp;ID=24618&amp;page=1”。参数可以允许有多个参数，参数与参数之间用“&amp;”作为分隔符。</p>
</blockquote>
<h2 id="HTTP状态码"><a href="#HTTP状态码" class="headerlink" title="HTTP状态码"></a>HTTP状态码</h2><p>状态代码有三位数字组成，第一个数字定义了响应的类别，共分五种类别:</p>
<p>1xx：指示信息–表示请求已接收，继续处理<br>2xx：成功–表示请求已被成功接收、理解、接受<br>3xx：重定向–要完成请求必须进行更进一步的操作<br>4xx：客户端错误–请求有语法错误或请求无法实现<br>5xx：服务器端错误–服务器未能实现合法的请求</p>
<p><strong>常见状态码：</strong></p>
<blockquote>
<p>200 OK                        //客户端请求成功<br>400 Bad Request               //客户端请求有语法错误，不能被服务器所理解<br>401 Unauthorized              //请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用<br>403 Forbidden                 //服务器收到请求，但是拒绝提供服务<br>404 Not Found                 //请求资源不存在，eg：输入了错误的URL<br>500 Internal Server Error     //服务器发生不可预期的错误<br>503 Server Unavailable        //服务器当前不能处理客户端的请求，一段时间后可能恢复正常</p>
</blockquote>
<h2 id="HTTP请求方式"><a href="#HTTP请求方式" class="headerlink" title="HTTP请求方式"></a>HTTP请求方式</h2><p>HTTP1.0定义了三种请求方法： GET, POST 和 HEAD方法。<br>HTTP1.1新增了五种请求方法：OPTIONS, PUT, DELETE, TRACE 和 CONNECT 方法。</p>
<ul>
<li><strong>GET</strong> 请求指定的页面信息，并返回实体主体。</li>
<li><strong>HEAD</strong> 类似于get请求，只不过返回的响应中没有具体的内容，用于获取报头</li>
<li><strong>POST</strong> 向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。</li>
<li><strong>PUT</strong> 从客户端向服务器传送的数据取代指定的文档的内容。</li>
<li><strong>DELETE</strong>  请求服务器删除指定的页面。</li>
<li><strong>CONNECT</strong> HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。</li>
<li><strong>OPTIONS</strong> 允许客户端查看服务器的性能。</li>
<li><strong>TRACE</strong> 回显服务器收到的请求，主要用于测试或诊断。<h4 id="get和post的区别"><a href="#get和post的区别" class="headerlink" title="get和post的区别"></a>get和post的区别</h4>HTTP中的GET，POST，PUT，DELETE就对应着对这个资源的查，改，增，删4个操作。GET一般用于获取/查询资源信息，而POST一般用于更新资源信息。<br>GET是向服务器发索取数据的一种请求，而POST是向服务器提交数据的一种请求；GET是获取信息，而不是修改信息，类似数据库查询功能一样，数据不会被修改<br><strong>GET 请求的一些特点：</strong><blockquote>
<p>Get请求的参数会跟在url后进行传递，请求的数据会附在URL之后，以?分割URL和传输数据，参数之间以&amp;相连,％XX中的XX为该符号以16进制表示的ASCII，如果数据是英文字母/数字，原样发送，如果是空格，转换为+，如果是中文/其他字符，则直接把字符串用BASE64加密。<br>Get传输的数据有大小限制，HTTP本身对Get数据大小没有限制，但是因为GET是通过URL提交数据，那么GET可提交的数据量就跟URL的长度有直接关系了，不同的浏览器对URL的长度的限制是不同的。<br>GET请求的数据会被浏览器缓存起来，用户名和密码将明文出现在URL上，其他人可以查到历史浏览记录，数据不太安全。在服务器端，用Request.QueryString来获取Get方式提交来的数据</p>
</blockquote>
</li>
</ul>
<p><strong>POST请求的特点：</strong></p>
<blockquote>
<p>Post请求则作为http消息的实际内容发送给web服务器，数据放置在HTML Header内提交，Post没有限制提交的数据。<br>Post比Get安全，当数据是中文或者不敏感的数据，则用get，因为使用get，参数会显示在地址，对于敏感数据和不是中文字符的数据，则用post;<br>POST可能修改服务器上的资源的请求，在服务器端，用Post方式提交的数据只能用Request.Form来获取</p>
</blockquote>
<pre><code>**GET请求**
GET /books/?sex=man&amp;name=Professional HTTP/1.1
Host: www.wrox.com
User-Agent: Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.7.6)
Gecko/20050225 Firefox/1.0.1
Connection: Keep-Alive
注意最后一行是空行

**POST请求**
POST / HTTP/1.1
Host: www.wrox.com
User-Agent: Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.7.6)
Gecko/20050225 Firefox/1.0.1
Content-Type: application/x-www-form-urlencoded
Content-Length: 40
Connection: Keep-Alive

name=Professional%20Ajax&amp;publisher=Wiley
</code></pre><p>参考：<a href="http://www.cnblogs.com/ranyonsue/p/5984001.html" target="_blank" rel="external">http://www.cnblogs.com/ranyonsue/p/5984001.html</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/05/22/css transition/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="fwp">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="fwp个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/05/22/css transition/" itemprop="url">css3 transition</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-05-22T15:10:40+08:00">
                2017-05-22
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/css/" itemprop="url" rel="index">
                    <span itemprop="name">css</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/05/22/css transition/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2017/05/22/css transition/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
             <span id="/2017/05/22/css transition/" class="leancloud_visitors" data-flag-title="css3 transition">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body han-init-context" itemprop="articleBody">

      
      

      
        
          
            <p>transition允许我们当元素从一种样式变换为另一种样式时，为元素添加过渡动画。<br>transition这个属性其实是 transition-property（变换的属性）, transition-duration（变换延续时间）, transition-timing-function（速率变化函数）, 和 transition-delay（变换延迟时间）的缩写属性。<br>下面是一些示例：</p>
<pre><code>/* 应用于1个属性上 */
/* property name | duration */
transition: margin-left 4s;

/* property name | duration | delay */
transition: margin-left 4s 1s;

/* property name | duration | timing function | delay */
transition: margin-left 4s ease-in-out 1s;

/* 应用于2个属性上 */
transition: margin-left 4s, color 1s;

/* 应用于所有改变了的属性上 */
transition: all 0.5s ease-out;
</code></pre><h3 id="transition-property（过渡属性）"><a href="#transition-property（过渡属性）" class="headerlink" title="transition-property（过渡属性）"></a>transition-property（过渡属性）</h3><ul>
<li>可以单独指定元素哪些属性改变时执行过渡（transition），可以触发浏览器reflow或repaint的属性那些CSS属性可以应用动画，可参见：<a href="https://developer.mozilla.org/zh-CN/docs/CSS/CSS_animated_properties" target="_blank" rel="external">mdn给出的可用属性</a>这里列出所有的CSS属性，如果可以做动画，那么会说明是如何设置。</li>
<li>可以指定为all，元素任何可过渡（transition）属性值变化时都将执行过渡（transition）效果。</li>
<li>可以指定为none时，动画立即停止。 </li>
<li>初始默认值为all</li>
</ul>
<h3 id="transition-duration（过渡持续时间）"><a href="#transition-duration（过渡持续时间）" class="headerlink" title="transition-duration（过渡持续时间）"></a>transition-duration（过渡持续时间）</h3><p>用来指定元素过度过程的持续时间，时间值，1s(秒)，4000ms(毫秒)。其默认值是0s，也可以理解为无过渡（transition）效果。</p>
<h3 id="transition-timing-function（过渡时间函数）"><a href="#transition-timing-function（过渡时间函数）" class="headerlink" title="transition-timing-function（过渡时间函数）"></a>transition-timing-function（过渡时间函数）</h3><p>指定CSS属性的变换速率，预设的有：ease, linear, ease-in, ease-out, ease-in-out, cubic-bezier(x1, y1, x2, y2)，默认值时ease。</p>
<ol>
<li>ease：（逐渐变慢）默认值，等同于贝塞尔曲线(0.25, 0.1, 0.25, 1.0).</li>
<li>linear：（匀速／线性），等同于贝塞尔曲线(0.0, 0.0, 1.0, 1.0). </li>
<li>ease-in：(加速)，等同于贝塞尔曲线(0.42,    0, 1.0, 1.0).</li>
<li>ease-out：（减速），等同于贝塞尔曲线(0, 0, 0.58, 1.0)</li>
<li>ease-in-out：（加速然后减速），等同于贝塞尔曲线(0.42, 0, 0.58, 1.0)      </li>
<li>cubic-bezier：通过贝塞尔曲线来计算“转换”过程中的属性值</li>
</ol>
<h3 id="transition-delay（过渡延迟函数）"><a href="#transition-delay（过渡延迟函数）" class="headerlink" title="transition-delay（过渡延迟函数）"></a>transition-delay（过渡延迟函数）</h3><p>指定一个动画开始执行的时间，即当改变元素属性值后多长时间开始执行“转换效果”，初始默认值为0</p>
<h3 id="其他情况：当属性值列表长度不一致时"><a href="#其他情况：当属性值列表长度不一致时" class="headerlink" title="其他情况：当属性值列表长度不一致时"></a>其他情况：当属性值列表长度不一致时</h3><p>以 transition-property 的值列表长度为标准，如果某个属性值列表长度短于它的，则重复值以长度一致， 例如:</p>
<pre><code>div {
    transition-property: opacity, left, top, height;
    transition-duration: 3s, 5s;
}
等同于
div {
    transition-property: opacity, left, top, height;
    transition-duration: 3s, 5s, 3s, 5s;
}
</code></pre><p>如果某个属性的值列表长于 transition-property 的，将被截短，例如：</p>
<pre><code>div {
    transition-property: opacity, left;
    transition-duration: 3s, 5s, 2s, 1s;
}
等同于
div {
    transition-property: opacity, left;
    transition-duration: 3s, 5s;
}
</code></pre><h3 id="执行效果触发"><a href="#执行效果触发" class="headerlink" title="执行效果触发"></a>执行效果触发</h3><h4 id="1-通过css伪类"><a href="#1-通过css伪类" class="headerlink" title="1. 通过css伪类"></a>1. 通过css伪类</h4><p>CSS中伪类执行动画包括：</p>
<p><img src="http://i.imgur.com/esac958.png" alt=""></p>
<h4 id="2-通过js修改样式或追加删除样式"><a href="#2-通过js修改样式或追加删除样式" class="headerlink" title="2. 通过js修改样式或追加删除样式"></a>2. 通过js修改样式或追加删除样式</h4><p>一般是鼠标事件操作和定时操作（window.setTimeout()，window.setInterval()</p>
<p>还应注意当一个元素使用过渡（transition）后，立即使用.appendChild()将其加入到DOM中或删除其display: none;。这被视为如果初始状态从来没有存在过那么元素总是在它的最终状态。克服这个限制最简单的办法是使用极少毫米数的window.setTimeout()</p>
<h3 id="transitionend事件"><a href="#transitionend事件" class="headerlink" title="transitionend事件"></a>transitionend事件</h3><p>transitionend 事件会在 CSS transition 过渡完成时触发. 当transition完成前被移除或者取消，比如移除css的transition-property 属性，此事件将不会被触发。<br>各个浏览器下事件的支持情况如下：</p>
<blockquote>
<p>Chrome：1.0 开始 webkitTransitionEnd<br>Firefox (Gecko)：4.0 (2.0) 开始 transitionend<br>Internet Explorer：10开始 transitionend<br>Opera：10.5 开始 oTransitionEnd； 12 开始 otransitionend； 12.10 开始 transitionend<br>Safari (WebKit）：3.2 开始 webkitTransitionEnd</p>
</blockquote>
<p>transitionend 事件会在每个过渡属性完成时都触发该事件<br>而且浏览器下还有不一致的地方，比如border过渡的时候，webkit下只触发一次,输出：</p>
<blockquote>
<p>过渡属性： border； 时间:2</p>
</blockquote>
<p>而firefox输出：</p>
<blockquote>
<p>过渡属性： border-left-color； 时间:2<br>过渡属性： border-bottom-color； 时间:2<br>过渡属性： border-right-color； 时间:2<br>过渡属性： border-top-color； 时间:2<br>过渡属性： border-left-width； 时间:2<br>过渡属性： border-bottom-width； 时间:2<br>过渡属性： border-right-width； 时间:2<br>过渡属性： border-top-width； 时间:2</p>
</blockquote>
<p>建议在使用的时候判断是否所有的属性是否已经过渡完成，或者判断特定的属性名，再来执行该事件。</p>
<h3 id="transition和animation的区别"><a href="#transition和animation的区别" class="headerlink" title="transition和animation的区别"></a>transition和animation的区别</h3><ul>
<li>transition完成后会保留过渡后的状态，而animation会跳至默认状态 </li>
<li>后者更精细，具体到每一祯都可以控制，而前者是平滑过渡。</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/05/21/有关session、cookie、jwt/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="fwp">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="fwp个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/05/21/有关session、cookie、jwt/" itemprop="url">有关session、cookie和jwt验证</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-05-21T16:20:11+08:00">
                2017-05-21
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/web/" itemprop="url" rel="index">
                    <span itemprop="name">web</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/05/21/有关session、cookie、jwt/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2017/05/21/有关session、cookie、jwt/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
             <span id="/2017/05/21/有关session、cookie、jwt/" class="leancloud_visitors" data-flag-title="有关session、cookie和jwt验证">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body han-init-context" itemprop="articleBody">

      
      

      
        
          
            <p>session指的是一个终端用户与交互系统进行通信的时间间隔（会话）<br>例如：用户访问某个网站，从他登录到退出的时间段就是session<br>由于http是是一种无状态的协议，故有这样一个情况：<br>用户首次登录某个网站后，当用户再次向服务器端发送请求时还要进行登录验证，为了避免用户重复登录的麻烦，就要用到基于session或基于token的验证了。<br>其原理就是让浏览器记住用户登录的信息，在下次请求时由浏览器代替用户进行登录验证。</p>
<h3 id="一-基于session的验证"><a href="#一-基于session的验证" class="headerlink" title="一 基于session的验证"></a>一 基于session的验证</h3><h4 id="1-简要过程"><a href="#1-简要过程" class="headerlink" title="1. 简要过程"></a>1. 简要过程</h4><ol>
<li>生成全局唯一标识符（sessionid）；</li>
<li>开辟数据存储空间。一般会在内存中创建相应的数据结构，但这种情况下，系统一旦掉电，所有的会话数据就会丢失，如果是电子商务网站，这种事故会造成严重的后果。不过也可以写到文件里甚至存储在数据库中，这样虽然会增加I/O开销，但session可以实现某种程度的持久化，而且更有利于session的共享；</li>
<li><p>将session的全局唯一标示符发送给客户端。<br>问题的关键就在服务端如何发送这个session的唯一标识上。联系到HTTP协议，数据无非可以放到请求行、头域或Body里，基于此，一般来说会有两种常用的方式：cookie和URL重写。</p>
<h4 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie　"></a>Cookie　</h4><p>服务端只要设置Set-cookie头就可以将session的标识符传送到客户端，而客户端此后的每一次请求都会带上这个标识符，服务器端可以为cookie设置失效时间，一般会设置失效时间为0，即浏览器进程有效时间。至于浏览器怎么处理这个0，每个浏览器都有自己的方案，但差别都不会太大（一般体现在新建浏览器窗口的时候）。</p>
<h4 id="URL重写"><a href="#URL重写" class="headerlink" title="URL重写"></a>URL重写</h4><p>所谓URL重写就是重写URL。在返回用户请求的页面之前，将页面内所有的URL后面全部以get参数的方式加上session标识符（或者加在path info部分等等），这样用户在收到响应之后，无论点击哪个链接或提交表单，都会在再带上session的标识符，从而就实现了会话的保持。这样做可以在客户端禁止使用cookie的时候也进行session认证。</p>
<h4 id="2-在express中使用session"><a href="#2-在express中使用session" class="headerlink" title="2. 在express中使用session"></a>2. 在express中使用session</h4><p>express-session 是基于express框专门用于处理session的中间件。由于session的认证机制离不开cookie，需要同时使用cookieParser 中间件。<br>express-session的常用参数:<br>secret:一个String类型的字符串，作为服务器端生成session的签名<br>name:返回客户端的key的名称，默认为connect.sid,也可以自己设置<br>resave:(是否允许)当客户端并行发送多个请求时，其中一个请求在另一个请求结束时对session进行修改覆盖并保存。默认为true。但是(后续版本)有可能默认失效，所以最好手动添加。<br>saveUninitialized:初始化session时是否保存到存储。默认为true，但是(后续版本)有可能默认失效，所以最好手动添加。<br>cookie:设置返回到前端key的属性，默认值为{ path: ‘/’, httpOnly: true, secure: false, maxAge: null }。<br><strong>express-session的一些方法:</strong><br>Session.destroy():删除session，当检测到客户端关闭时调用。<br>Session.reload():当session有修改时，刷新session。<br>Session.regenerate()：将已有session初始化。<br>Session.save()：保存session。 </p>
<h4 id="3-基于session验证存在的问题"><a href="#3-基于session验证存在的问题" class="headerlink" title="3. 基于session验证存在的问题"></a>3. 基于session验证存在的问题</h4><p><strong>1）存储:</strong> 每个用户经过我们的应用认证之后，我们的应用都要在服务端做一次记录，以方便用户下次请求的鉴别，通常而言session都是保存在内存或文件、数据库中，而随着认证用户的增多，服务端的开销会明显增大。<br><strong>2）扩展性:</strong> 用户认证之后，服务端做认证记录，如果认证的记录被保存在内存中的话，这意味着用户下次请求还必须要请求在特定的这台服务器上,才能拿到授权的资源，这样在分布式的应用上，限制了负载均衡器的能力。这也限制了应用的扩展能力。<br><strong>3）CSRF:</strong> 因为是基于cookie来进行用户识别的, cookie如果被截获，用户就会很容易受到跨站请求伪造的攻击。</p>
<h3 id="二-基于token的验证（jwt）"><a href="#二-基于token的验证（jwt）" class="headerlink" title="二 基于token的验证（jwt）"></a>二 基于token的验证（jwt）</h3><p>基于token的鉴权机制类似于http协议也是无状态的，它不需要在服务端去保留用户的认证信息或者会话信息。<br><strong>基本过程</strong><br>1）用户使用用户名密码来请求服务器<br>2）服务器进行验证用户的信息<br>3）服务器通过验证发送给用户一个token<br>4）客户端存储token(可采用cookie或sessionStorage、localStorage)，并在每次请求时附送上这个token值<br>5）服务端验证token值，并返回数据<br>这个token必须要在每次请求时传递给服务端，它应该保存在请求头里， 另外，服务端要支持CORS(跨来源资源共享)策略。</p>
<h4 id="1-JWT的构成"><a href="#1-JWT的构成" class="headerlink" title="1. JWT的构成"></a>1. JWT的构成</h4><p>JWT是由三段信息构成的，将这三段信息用.链接一起就构成了Jwt字符串。<br>第一部分称为头部（header), 第二部分称为载荷（payload), 第三部分是签证（signature).</p>
<p> // 1. Headers<br> // 包括类别（typ）、加密算法（alg）；<br> {</p>
<pre><code>&quot;alg&quot;: &quot;HS256&quot;,
&quot;typ&quot;: &quot;JWT&quot;
</code></pre><p> }<br> // 2. Claims<br> // 包括需要传递的用户信息；<br> {</p>
<pre><code>&quot;sub&quot;: &quot;1234567890&quot;,
&quot;name&quot;: &quot;John Doe&quot;,
&quot;admin&quot;: true
</code></pre><p> }<br> // 3. Signature<br> // 根据alg算法与私有秘钥进行加密得到的签名字串；<br> // 这一段是最重要的敏感信息，只能在服务端解密；<br> HMACSHA256(</p>
<pre><code>base64UrlEncode(header) + &quot;.&quot; +
base64UrlEncode(payload),
SECREATE_KEY
</code></pre><p> )<br><strong>（1）头部header</strong><br>jwt的头部承载两部分信息：声明类型，这里是jwt；声明加密的算法 通常直接使用 HMAC SHA256。完整的头部就像下面这样的JSON：</p>
<p> {</p>
<pre><code>&apos;typ&apos;: &apos;JWT&apos;,
&apos;alg&apos;: &apos;HS256&apos;
</code></pre><p> }<br>将头部进行base64编码（该加密是可以对称解码的),构成了第一部分</p>
<p> eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9<br><strong>（2）载荷payload</strong><br>载荷就是存放有效信息的地方，这些有效信息包含三个部分：标准中注册的声明、公共的声明、私有的声明。<br><strong>1）标准中注册的声明 (建议但不强制使用) ：</strong><br><strong>iss:</strong> jwt签发者<br><strong>sub:</strong> jwt所面向的用户<br><strong>aud:</strong> 接收jwt的一方<br><strong>exp:</strong> jwt的过期时间，这个过期时间必须要大于签发时间<br><strong>nbf:</strong> 定义在什么时间之前，该jwt都是不可用的.<br><strong>iat:</strong> jwt的签发时间<br><strong>jti:</strong> jwt的唯一身份标识，主要用来作为一次性token,从而回避重放攻击。<br><strong>2）公共的声明 ：</strong><br>公共的声明可以添加任何的信息，一般添加用户的相关信息或其他业务需要的必要信息。不建议添加敏感信息，因为该部分在客户端可解密。<br><strong>3）私有的声明 ：</strong><br>私有声明是提供者和消费者所共同定义的声明，一般不建议存放敏感信息，因为base64是对称解码的，意味着该部分信息可以归类为明文信息。<br>定义一个payload:</p>
<p> {</p>
<pre><code>&quot;sub&quot;: &quot;1234567890&quot;,
&quot;name&quot;: &quot;John Doe&quot;,
&quot;admin&quot;: true
</code></pre><p> }<br>然后将其进行base64加密，得到Jwt的第二部分。</p>
<p> eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9<br><strong>签证signature</strong><br>jwt的第三部分是一个签证信息，这个签证信息由三部分组成：header (base64后的)、payload (base64后的)、secret。<br>这个部分需要base64编码后的header和base64编码后的payload使用.连接组成的字符串，然后通过header中声明的编码方式进行加盐secret组合加密，然后就构成了jwt的第三部分。</p>
<p> var encodedString = base64UrlEncode(header) + ‘.’ + base64UrlEncode(payload);<br> var signature = HMACSHA256(encodedString, ‘secret’); // TJVA95OrM7E2cBab30RMHrHDcEfxjoYZgeFONFh7HgQ</p>
</li>
</ol>
<p>将header、payload和signature三部分用.连接起来就形成了整个jwt字符串。<br>secret是保存在服务器端的，jwt的签发生成也是在服务器端的，secret就是用来进行jwt的签发和jwt的验证，所以，它就是你服务端的私钥，在任何场景都不应该流露出去。一旦客户端得知这个secret, 那就意味着客户端是可以自我签发jwt了。</p>
<h4 id="2-使用jwt"><a href="#2-使用jwt" class="headerlink" title="2. 使用jwt"></a>2. 使用jwt</h4><p>客户端发送请求，可以将token设为请求地址参数或请求body参数或在请求头部分设置Authorization字段（推荐）传给服务器：</p>
<pre><code>fetch(&apos;api/user/1&apos;, {
    headers: {
        &apos;Authorization&apos;: &apos;Bearer &apos; + token
    }
})
</code></pre><p>服务器端收到请求后，根据请求头部token的header部分的加密算法和plaload加上自己的secret生成第三部分内容。然后再与客户端发送过来的第三部分内容对比。<br><strong>express使用jwt</strong><br>服务器端在验证用户登录成功后，设置token，并返回给客户端：</p>
<pre><code>var express = require(&apos;express&apos;);
var jwt = require(&apos;jwt-simple&apos;);
var app = express();
app.set(&apos;jwtTokenSecret&apos;, &apos;YOUR_SECRET_STRING&apos;);

var expires = moment().add(&apos;days&apos;, 7).valueOf();
var token = jwt.encode({
    iss: user.id,
    exp: expires
}, app.get(&apos;jwtTokenSecret&apos;));

res.json({
    token : token,
    expires: expires,
    user: user.toJSON()
});
</code></pre><p>jwt.encode()函数有2个参数。第一个就是一个需要编码的token对象，第二个是一个编码的密钥。Moment.js被用来设置token将在7天之后失效。最后通过res.json()方法返回这个JSON对象给客户端。<br>客户端接受到token后存储，待下次请求时将token传给服务器端验证。</p>
<h4 id="3-jwt的优点和安全相关问题"><a href="#3-jwt的优点和安全相关问题" class="headerlink" title="3. jwt的优点和安全相关问题"></a>3. jwt的优点和安全相关问题</h4><p><strong>优点：</strong><br>1）因为json的通用性，所以JWT是可以进行跨语言支持的，像JAVA,JavaScript,NodeJS,PHP等很多语言都可以使用。<br>2）因为有了payload部分，所以JWT可以在自身存储一些其他业务逻辑所必要的非敏感信息。<br>3）便于传输，jwt的构成非常简单，字节占用很小，所以它是非常便于传输的。<br>4）它不需要在服务端保存会话信息, 所以它易于应用的扩展。<br><strong>安全相关注意事项：</strong><br>1）不应该在jwt的payload部分存放敏感信息，因为该部分是客户端可解密的部分。<br>2）保护好secret私钥，该私钥非常重要。<br>3）如果可以，请使用https协议。<br>4）使用jwe，及rsa加密。<br><strong>可能发生的安全问题：</strong><br><strong>XSS：</strong> XSS是Web中最常见的一种漏洞，其主要原因是对用户输入信息不加过滤，导致用户（被误导）恶意输入的Js代码在访问该网页时被执行，而Js可以读取当前网站域名下保存的Cookie信息。<br>针对这种攻击，无论将jwt存储在Cookie还是localStorage中，信息都有可能被窃取，为了防止XSS攻击，需要对用户输入的所有信息进行过滤。<br><strong>XSRF：</strong>主要利用Cookie是按照域名存储，同时访问某域名时浏览器会自动携带该域名所保存的Cookie信息这一特征。如果执意要将JWT存储在Cookie中，服务端则需要额外验证请求来源，或者在提交表单中加入随机签名并在处理表单时进行验证。</p>
<p>参考链接：</p>
<p><a href="http://www.jianshu.com/p/576dbf44b2ae" target="_blank" rel="external">什么是jwt</a><br><a href="http://blog.csdn.net/offbye/article/details/47617367" target="_blank" rel="external">nodejs中使用jwt</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/05/21/css3 transform/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="fwp">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="fwp个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/05/21/css3 transform/" itemprop="url">css3 transform</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-05-21T16:20:11+08:00">
                2017-05-21
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/css/" itemprop="url" rel="index">
                    <span itemprop="name">css</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/05/21/css3 transform/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2017/05/21/css3 transform/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
             <span id="/2017/05/21/css3 transform/" class="leancloud_visitors" data-flag-title="css3 transform">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body han-init-context" itemprop="articleBody">

      
      

      
        
          
            <h2 id="转换（transform）"><a href="#转换（transform）" class="headerlink" title="转换（transform）"></a>转换（transform）</h2><p>通过 CSS3 转换，我们能够对元素进行移动、缩放、转动、拉长或拉伸。<br>transform：[transform-functions]</p>
<h3 id="2d转换"><a href="#2d转换" class="headerlink" title="2d转换"></a>2d转换</h3><p>transform方法包括：</p>
<ul>
<li>translate() - 移位</li>
<li>rotate() - 旋转</li>
<li>scale() - 放大或缩小</li>
<li>skew() - 偏斜</li>
<li>matrix() - 综合变换</li>
</ul>
<h4 id="1-translate"><a href="#1-translate" class="headerlink" title="1. translate"></a>1. translate</h4><p>通过 translate() 方法，根据给定的 left（x 坐标） 和 top（y 坐标） 位置参数，元素从其当前位置移动。<br>值 translate(50px,100px) 把元素从左侧移动 50 像素，从顶端移动 100 像素。<strong>值 translate(50px) 相当于 translateX(50px)</strong><br>兼容写法：</p>
<pre><code>div {
    transform: translate(50px,100px);
    -ms-transform: translate(50px,100px);      //IE 9 
    -webkit-transform: translate(50px,100px); //Safari and Chrome
    -o-transform: translate(50px,100px);      //Opera 
    -moz-transform: translate(50px,100px);      //Firefox
}
</code></pre><p>同时有 translateX() 方法和 translateY() 方法</p>
<h4 id="2-rotate"><a href="#2-rotate" class="headerlink" title="2. rotate"></a>2. rotate</h4><p>通过 rotate() 方法，元素顺时针旋转给定的角度。允许负值，元素将逆时针旋转。<br>值 rotate(30deg) 把元素顺时针旋转 30 度。<strong>相当于rotateZ(30deg)。</strong><br>兼容写法：</p>
<pre><code>div {
    transform: rotate(30deg);
    -ms-transform: rotate(30deg);      //IE 9 
    -webkit-transform: rotate(30deg); //Safari and Chrome
    -o-transform: rotate(30deg);      //Opera 
    -moz-transform: rotate(30deg);      //Firefox
}
</code></pre><h4 id="3-scale"><a href="#3-scale" class="headerlink" title="3. scale"></a>3. scale</h4><p>通过 scale() 方法，根据给定的宽度（X 轴）和高度（Y 轴）参数，元素的尺寸会增加或减少。尺寸是number类型，可以是小数。<br><strong>值 scale(2) 把宽高都扩大2倍</strong>； scale(2,4) 把宽度转换为原始尺寸的 2 倍，把高度转换为原始高度的 4 倍。<br>兼容写法同上，transform 后的 function改成 scale(2, 4) 即可。<br>同时有 scaleX() 方法和 scaleY() 方法</p>
<h4 id="4-skew"><a href="#4-skew" class="headerlink" title="4. skew"></a>4. skew</h4><p>通过 skew() 方法，根据给定的水平线（X 轴）和垂直线（Y 轴）参数，元素偏斜／翻转给定的角度。<br>值 skew(30deg,20deg) 围绕 X 轴把元素翻转 30 度，围绕 Y 轴翻转 20 度。<strong>值 skew(30deg) 相当于 skewX(30deg) 围绕 X 轴把元素翻转 30 度。</strong><br>同时有 skewX() 方法和 skewY() 方法</p>
<h4 id="5-matrix"><a href="#5-matrix" class="headerlink" title="5. matrix"></a>5. matrix</h4><p>matrix() 方法把所有 2D 转换方法组合在一起。<br>matrix() 方法需要六个参数，包含数学函数，允许旋转、缩放、移动以及倾斜元素。<br>matrix方法是根据一个3<em>3的矩阵和另一个3</em>1矩阵相乘来实现图形变换的，上述提到过的translate、rotate、scale、skew方法都可以转换成matrix，其实现原理都是由matrix而来。<br>matrix(a, b, c, d, tx, ty)六个参数对应的矩阵如下：</p>
<blockquote>
<p>  a c tx<br>    b d ty<br>    0 0  1</p>
</blockquote>
<p><strong>transform：</strong>其中tx、ty表示需要移动的x，y坐标，上述矩阵与由transform中心x、y而定的另一个矩阵相乘，最终会得到移动后的x、y坐标。<br>如：transform: matrix(1, 0, 0, 1, 30, 30), 假设transform中心是（0, 0)</p>
<pre><code>1 0 30      0       1*0+0*0+30*1     30
0 1 30  *   0   =   0*0+1*0+30*1  =  30
0 0  1      1       0*0+0*0+1*1       1
</code></pre><p>故等同于transform：translate(30px, 30px), 要实现translate效果只需改变matrix的后两位参数tx、ty的值</p>
<p><strong>scale:</strong><br>缩放同translate类似也只需改变matrix的两个参数，即matrix(1, 0, 0, 1, tx, ty)中两个1所在位置的参数，其中前者是横向缩放比例，后者是纵向缩放比例<br>matrix(sx, 0, 0, sy, 0, 0)等同于scale(sx, sy)</p>
<p><strong>rotate:</strong><br>假设是rotate(θ), matrix(cosθ, sinθ, -sinθ, cosθ, 0, 0), 结合矩阵公式，可以算出中心点应该在的x、y位置</p>
<pre><code>x&apos; = x*cosθ-y*sinθ+0 = x*cosθ-y*sinθ
y&apos; = x*sinθ+y*cosθ+0 = x*sinθ+y*cosθ
</code></pre><p><strong>skew：</strong><br>skew(θx, θy) 等同于 matrix(1, tan(θy), tan(θx), 1, 0, 0)</p>
<p>用matrix可以实现以上方法不能实现的更复杂的变换，如镜像变换，假设我们要根据y=kx进行镜像变换（其中k是斜率），那么matrix函数应该这样写：</p>
<pre><code>matrix((1-k*k) / (1+k*k), 2k / (1 + k*k), 2k / (1 + k*k), (k*k - 1) / (1+k*k), 0, 0)
</code></pre><p>matrix的参数是计算出来的，已知点(x, y)坐标，求其对称点(x’, y’)的坐标：</p>
<blockquote>
<p>(y-y’) / (x - x’) = -1/ k → ky-ky’ = -x+x’<br>(x + x’) / 2 <em> k = (y + y’)/2 → kx+kx’ = y+y’<br>得到<br>x’ = (1-k</em>k)/(k<em>k+1) </em>x + 2k/(k<em>k+1) </em>y<br>y’ = 2k/(k<em>k+1) </em>x + (k<em>k-1)/(k</em>k+1) <em>y<br>再结合矩阵计算公式：<br>x’ = ax+cy+tx<br>y’ = bx+dy+ty<br>计算出：<br>a = (1-k</em>k)/(k<em>k+1);<br>b = 2k/(k</em>k+1);<br>c = 2k/(k<em>k+1);<br>d = (k</em>k-1)/(k*k+1);</p>
</blockquote>
<p>2d变换中，可以通过设置transform-origin来改变变换的中心点。（3d也适用）</p>
<h3 id="3d转换"><a href="#3d转换" class="headerlink" title="3d转换"></a>3d转换</h3><h4 id="1-translate-1"><a href="#1-translate-1" class="headerlink" title="1. translate"></a>1. translate</h4><p>比起2d转换多了个translateZ和translate3d(x,y,z)的方法，translateZ控制元素朝我们远近移动，朝远处移动元素就变小，朝近处移动元素就变大。</p>
<p>3d变换中有个叫做透视（perspective）的属性，若我们设置perspective：201px，则其子元素设置的translateZ值越小，则子元素的大小就越小（因为元素远去，我们眼睛看到的就会变小）；translateZ值越大，该元素也会越来越大，当translateZ值非常接近201像素，但是不超过201像素的时候（如200像素），该元素的大小就会撑满整个屏幕（如果父辈元素没有类似overflow:hidden的限制的话）；当translateZ值再变大，超过201像素的时候，该元素看不见了。</p>
<p>perspective属性有两种书写形式，一种用在舞台元素上（动画元素们的共同父辈元素）；第二种就是用在当前动画元素上，与transform的其他属性写在一起。</p>
<p>perspective-origin属性就是透视的中心点</p>
<h4 id="2-scale"><a href="#2-scale" class="headerlink" title="2. scale"></a>2. scale</h4><p>scale有scale3d和scaleZ的方法</p>
<h4 id="3-rotate"><a href="#3-rotate" class="headerlink" title="3. rotate"></a>3. rotate</h4><p>rotate3d(x,y,z,angle)，其中x、y、z是相对于各个轴旋转角度的系数，即相对x轴旋转x<em>angle度，相对于y轴旋转y</em>angle度，相对于z轴旋转z*angle度。</p>
<h4 id="4-matrix"><a href="#4-matrix" class="headerlink" title="4. matrix"></a>4. matrix</h4><p>matrix3d是综合上述的方法，它有16个参数，从而构成一个4*4的矩阵。</p>
<h4 id="5-其他属性"><a href="#5-其他属性" class="headerlink" title="5. 其他属性"></a>5. 其他属性</h4><p><strong>（1）transform-style</strong><br>transform-style属性也是3D效果中经常使用的，其两个参数，flat|preserve-3d. 前者flat为默认值，表示平面的；后者preserve-3d表示3D透视。<br><strong>（2）backface-visibility</strong><br>在现实世界中，我们无法穿过物体A看到其后面的物体B或C或D；但是，在CSS3的3D世界中，默认情况下，我们是可以看到背后的元素。<br>因此，为了切合实际，我们常常会设置backface-visibility：hidden，使后面元素不可见。</p>
<h4 id="6-实际应用"><a href="#6-实际应用" class="headerlink" title="6. 实际应用"></a>6. 实际应用</h4><p><strong>图片的旋转木马效果</strong><br>因为要正好绕成一个圈，因此，图片rotateY值正好0~360等分，于是，如果有9张图片，则每个图片的旋转角度累加40(360 / 9 = 40)度即可</p>
<pre><code>img:nth-child(1) { transform: rotateY(   0deg ); }
img:nth-child(2) { transform: rotateY(  40deg ); }
img:nth-child(3) { transform: rotateY(  80deg ); }
img:nth-child(4) { transform: rotateY( 120deg ); }
img:nth-child(5) { transform: rotateY( 160deg ); }
img:nth-child(6) { transform: rotateY( 200deg ); }
img:nth-child(7) { transform: rotateY( 240deg ); }
img:nth-child(8) { transform: rotateY( 280deg ); }
img:nth-child(9) { transform: rotateY( 320deg ); }
</code></pre><p>这样以后，9张图的角度虽然不一样，但是它们都站在同一个点上，早就挤作一团。9张图分别面朝东南西北等共9个不同方位，只要将它们都向前移动4~5步（即使用translateZ），它们之间的空间就会拉开了，呈现出圆形。<br>translateZ方法的参数通过计算得出，假设上述每个img的宽度都为178px，距离r的值则为：</p>
<pre><code>r = （128 / 2) / Math.tan((40 / 2) / 180 * Math.PI) ≈ 175.8
</code></pre><p>为了好看，图片之间可以留了点间距，则使用的translateZ的值为175.8 + 20 = 195.8<br>最后只要写js代码，每次点击让容器每次沿y轴旋转40度就可以了。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/05/21/网络-体系结构及TCP-IP/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="fwp">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="fwp个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/05/21/网络-体系结构及TCP-IP/" itemprop="url">网络体系结构及TCP/TP协议</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-05-21T16:20:11+08:00">
                2017-05-21
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/网络/" itemprop="url" rel="index">
                    <span itemprop="name">网络</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/05/21/网络-体系结构及TCP-IP/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2017/05/21/网络-体系结构及TCP-IP/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
             <span id="/2017/05/21/网络-体系结构及TCP-IP/" class="leancloud_visitors" data-flag-title="网络体系结构及TCP/TP协议">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body han-init-context" itemprop="articleBody">

      
      

      
        
          
            <h2 id="OSI模型及TCP／IP模型及各层协议"><a href="#OSI模型及TCP／IP模型及各层协议" class="headerlink" title="OSI模型及TCP／IP模型及各层协议"></a>OSI模型及TCP／IP模型及各层协议</h2><h4 id="1-OSI-6层体系结构"><a href="#1-OSI-6层体系结构" class="headerlink" title="1.OSI 6层体系结构"></a>1.OSI 6层体系结构</h4><p>物理层-》数据链路层-》网络层-》传输层-》会话层-》表示层-》应用层<br>每一层协议如下：</p>
<blockquote>
<p>物理层：RJ45、CLOCK、IEEE802.3 （中继器，集线器）<br>数据链路：PPP、FR、HDLC、VLAN、MAC （网桥，交换机）<br>网络层：IP、ICMP、ARP、RARP、OSPF、IPX、RIP、IGRP、 （路由器）<br>传输层：TCP、UDP、SPX<br>会话层：NFS、SQL、NETBIOS、RPC<br>表示层：JPEG、MPEG、ASII<br>应用层：FTP、DNS、Telnet、SMTP、HTTP、WWW、NFS</p>
</blockquote>
<p>每一层的作用如下：</p>
<blockquote>
<p>物理层：通过媒介传输比特,确定机械及电气规范（比特Bit）<br>数据链路层：将比特组装成帧和点到点的传递（帧Frame）<br>网络层：负责数据包从源到宿的传递和网际互连（包PackeT）<br>传输层：提供端到端的可靠报文传递和错误恢复（段Segment）<br>会话层：建立、管理和终止会话（会话协议数据单元SPDU）<br>表示层：对数据进行翻译、加密和压缩（表示协议数据单元PPDU）<br>应用层：允许访问OSI环境的手段（应用协议数据单元APDU）</p>
</blockquote>
<h4 id="2-TCP-IP-4层体系结构"><a href="#2-TCP-IP-4层体系结构" class="headerlink" title="2.TCP/IP 4层体系结构"></a>2.TCP/IP 4层体系结构</h4><p>网络接口层-》网际层-》传输层-》应用层</p>
<h4 id="3-5层体系结构"><a href="#3-5层体系结构" class="headerlink" title="3. 5层体系结构"></a>3. 5层体系结构</h4><p>物理层-》数据链路层-》网络层-》传输层-》应用层</p>
<h2 id="TCP／IP协议簇"><a href="#TCP／IP协议簇" class="headerlink" title="TCP／IP协议簇"></a>TCP／IP协议簇</h2><h4 id="1-TCP协议："><a href="#1-TCP协议：" class="headerlink" title="1.TCP协议："></a>1.TCP协议：</h4><p>Transmission Control Protocol 传输控制协议<br>是一种面向连接的、可靠的、基于字节流的传输层通信协议<br><strong>TCP三次握手和四次挥手</strong><br><strong>三次握手：</strong></p>
<blockquote>
<p><strong>第一次握手</strong>：客户端发送syn包(syn=1, seq=x)到服务器，并进入SYN_SEND状态，等待服务器确认；<br><strong>第二次握手</strong>：服务器收到syn包，必须确认客户的SYN（ack=x+1），同时自己也发送一个SYN包（syn=1,seq=y），即SYN+ACK包，此时服务器进入SYN_RECV状态；<br><strong>第三次握手</strong>：客户端收到服务器的SYN＋ACK包，向服务器发送SYN(syn=0, seq=x+1)及确认包ACK(ack=y+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。<br>握手过程中传送的包里不包含数据，三次握手完毕后，客户端与服务器才正式开始传送数据。理想状态下，TCP连接一旦建立，在通信双方中的任何一方主动关闭连接之前，TCP 连接都将被一直保持下去。</p>
</blockquote>
<p><strong>四次挥手：</strong></p>
<blockquote>
<p>与建立连接的“三次握手”类似，断开一个TCP连接则需要“四次握手”。<br><strong>第一次挥手</strong>：主动关闭方发送一个FIN，用来关闭主动方到被动关闭方的数据传送，也就是主动关闭方告诉被动关闭方：我已经不 会再给你发数据了(当然，在fin包之前发送出去的数据，如果没有收到对应的ack确认报文，主动关闭方依然会重发这些数据)，但是，此时主动关闭方还可以接受数据。<br><strong>第二次挥手</strong>：被动关闭方收到FIN包后，发送一个ACK给对方，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号）。<br><strong>第三次挥手</strong>：被动关闭方发送一个FIN，用来关闭被动关闭方到主动关闭方的数据传送，也就是告诉主动关闭方，我的数据也发送完了，不会再给你发数据了。<br><strong>第四次挥手</strong>：主动关闭方收到FIN后，发送一个ACK给被动关闭方，确认序号为收到序号+1，至此，完成四次挥手。</p>
</blockquote>
<h4 id="2-IP协议"><a href="#2-IP协议" class="headerlink" title="2.IP协议"></a>2.IP协议</h4><p>IP协议是用于将多个包交换网络连接起来的，它在源地址和目的地址之间传送一种称之为数据包的东西，它还提供对数据大小的重新组装功能，以适应不同网络对包大小的要求<br>IP实现两个基本功能：寻址和分段。<br>IP可以根据数据包包头中包括的目的地址将数据包传送到目的地址，在此过程中IP负责选择传送的道路，这种选择道路称为路由功能。<br>如果有些网络内只能传送小数据包，IP可以将数据包重新组装并在报头域内注明。</p>
<h4 id="3-UDP协议"><a href="#3-UDP协议" class="headerlink" title="3.UDP协议"></a>3.UDP协议</h4><p>User Datagram Protocol 用户数据报协议<br>在网络中它与TCP协议一样用于处理数据包，是一种无连接的协议。在OSI模型中，在第四层——传输层，处于IP协议的上一层。UDP有不提供数据包分组、组装和不能对数据包进行排序的缺点，也就是说，当报文发送之后，是无法得知其是否安全完整到达的。</p>
<h4 id="4-TCP与UDP的区别"><a href="#4-TCP与UDP的区别" class="headerlink" title="4.TCP与UDP的区别"></a>4.TCP与UDP的区别</h4><p>TCP提供面向连接的、可靠的数据流传输，而UDP提供的是非面向连接的、不可靠的数据流传输。<br>TCP传输单位称为TCP报文段，UDP传输单位称为用户数据报。<br>TCP注重数据安全性，UDP数据传输快，因为不需要连接等待，少了许多操作，但是其安全性却一般。<br><strong>TCP和UDP分别对应的协议</strong><br><strong>TCP对应的协议：</strong></p>
<ul>
<li><strong>FTP</strong>：定义了文件传输协议，使用21端口。</li>
<li><strong>Telnet</strong>：一种用于远程登陆的端口，使用23端口，用户可以以自己的身份远程连接到计算机上，可提供基于DOS模式下的通信服务。</li>
<li><strong>SMTP</strong>：邮件传送协议，用于发送邮件。服务器开放的是25号端口。</li>
<li><strong>POP3</strong>：它是和SMTP对应，POP3用于接收邮件。POP3协议所用的是110端口。</li>
<li><strong>HTTP</strong>：是从Web服务器传输超文本到本地浏览器的传送协议。<br><strong>UDP对应的协议：</strong></li>
<li><strong>DNS</strong>：用于域名解析服务，将域名地址转换为IP地址。DNS用的是53号端口。</li>
<li><strong>SNMP</strong>：简单网络管理协议，使用161号端口，是用来管理网络设备的。由于网络设备很多，无连接的服务就体现出其优势。</li>
<li><strong>TFTP</strong>：(Trival File Tran敏感词er Protocal)，简单文件传输协议，该协议在熟知端口69上使用UDP服务。<h4 id="5-TCP建立连接为什么会采用三次握手，若采用二次握手可以吗？"><a href="#5-TCP建立连接为什么会采用三次握手，若采用二次握手可以吗？" class="headerlink" title="5. TCP建立连接为什么会采用三次握手，若采用二次握手可以吗？"></a>5. TCP建立连接为什么会采用三次握手，若采用二次握手可以吗？</h4><blockquote>
<p>“已失效的连接请求报文段”的产生在这样一种情况下：</p>
</blockquote>
</li>
</ul>
<blockquote>
<p> client发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达server。<br>  本来这是一个早已失效的报文段,但server收到此失效的连接请求报文段后，就误认为是client再次发出的一个新的连接请求。<br>  于是就向client发出确认报文段，同意建立连接。</p>
<p> 假设不采用“三次握手”，那么只要server发出确认，新的连接就建立了。<br>  由于现在client并没有发出建立连接的请求，因此不会理睬server的确认，也不会向server发送数据,但server却以为新的运输连接已经建立，并一直等待client发来数据。<br>  这样，server的很多资源就白白浪费掉了。</p>
<p> 采用“三次握手”的办法可以防止上述现象发生。<br>  例如刚才那种情况，client不会向server的确认发出确认,server由于收不到确认，就知道client并没有要求建立连接。”</p>
</blockquote>
<p>参考：</p>
<p><a href="http://blog.csdn.net/whuslei/article/details/6667471" target="_blank" rel="external">http://blog.csdn.net/whuslei/article/details/6667471</a> 以及<br>牛客网</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/05/21/http缓存机制/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="fwp">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="fwp个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/05/21/http缓存机制/" itemprop="url">http缓存机制</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-05-21T16:20:11+08:00">
                2017-05-21
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/网络/" itemprop="url" rel="index">
                    <span itemprop="name">网络</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/05/21/http缓存机制/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2017/05/21/http缓存机制/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
             <span id="/2017/05/21/http缓存机制/" class="leancloud_visitors" data-flag-title="http缓存机制">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body han-init-context" itemprop="articleBody">

      
      

      
        
          
            <h3 id="什么是cache？"><a href="#什么是cache？" class="headerlink" title="什么是cache？"></a>什么是cache？</h3><p>浏览器缓存（Browser Caching）是为了加速浏览，浏览器在用户磁盘上对最近请求过的文档进行存储，当访问者再次请求这个页面时，浏览器就可以从本地磁盘显示文档，这样就可以加速页面的阅览。<br>chrome控制台下的Frames即展示的是浏览器的http文件级缓存。<br><strong>cache的作用：</strong><br>1、减少延迟，让你的网站更快，提高用户体验。<br>2、避免网络拥塞，减少请求量，减少输出带宽。<br><strong>过程：</strong><br>主要是针对重复的http请求，在有缓存的情况下判断过程分3步：<br>1) 判断expires，如果未过期，直接读取http缓存文件，不发http请求，否则进入下一步。<br>2) 判断是否含有etag，有则带上if-none-match发送请求，未修改返回304，修改返回200，否则进入下一步。<br>3) 判断是否含有last-modified，有则带上if-modified-since发送请求，无效返回200，有效返回304，否则直接向服务器请求。 </p>
<h3 id="200-OK-From-Cache"><a href="#200-OK-From-Cache" class="headerlink" title="200 OK(From Cache)"></a>200 OK(From Cache)</h3><p>浏览器没有向服务器端发送请求，而是直接使用了浏览器自己本地的缓存数据。200 OK指浏览器向服务器发送请求并获得了最新更新的数据。<br><strong>触发时机：</strong>直接点击链接访问或输入网址按回车访问</p>
<h3 id="304-Not-Modified"><a href="#304-Not-Modified" class="headerlink" title="304(Not Modified)"></a>304(Not Modified)</h3><p>浏览器首先向服务器发送请求，确认数据是否发生改变，若没有改变，则加载浏览器自己的缓存数据。<br><strong>触发时机：</strong>刷新页面、设置了长缓存或ETags</p>
<p>当你第一次访问时，服务器会返回给你200状态码，同时在头里追加ETag值给你。浏览器拿到后将其缓存。<br>下一次再访问时，因浏览器已经有该地址的ETag值了。会将其缓存的ETag值内容放在请求头的If-None-Match中，服务器检查其自身内容的ETag值是否与其一致，如果一致就会返回304状态码，告诉你内容和你保存的一致，没有发生改变过。</p>
<h3 id="http缓存基础知识"><a href="#http缓存基础知识" class="headerlink" title="http缓存基础知识"></a>http缓存基础知识</h3><h4 id="http报文中与缓存相关的首部字段"><a href="#http报文中与缓存相关的首部字段" class="headerlink" title="http报文中与缓存相关的首部字段"></a>http报文中与缓存相关的首部字段</h4><p><strong>通用首部字段</strong><br>Cache-Control：控制缓存的行为<br>Pragma：http1.0，值为‘no-cache’禁用缓存<br><strong>请求首部字段</strong><br>if-Match：比较ETag是否一致<br>if-None-Match：比较ETag是否不一致<br>if-Modified-Since：比较资源最后更新时间是否一致<br>if-Unmodified-Since：比较资源最后更新时间是否不一致<br><strong>相应首部字段</strong><br>ETag：资源的匹配信息<br><strong>实体首部字段</strong><br>Expires：http1.0，实体主体过期的时间<br>last-Modified：资源最后一次修改的时间</p>
<h4 id="设置缓存行为"><a href="#设置缓存行为" class="headerlink" title="设置缓存行为"></a>设置缓存行为</h4><ol>
<li>http1.0通过Expires设置缓存过期时间（为一个GMT时间），如果还没过该时间点则不发送请求；通过Pragma来禁用缓存。优先级Pragma &gt; Expires</li>
<li>http1.1新增Cache-Control字段来控制缓存，Cache-Control在请求和响应报文中都能使用。优先级Cache-Control &gt; Pragma &gt; Expires<br><strong>请求中的取值：</strong></li>
</ol>
<blockquote>
<p><strong>no-cache：</strong>告知服务器不使用缓存，要求向原服务器发起请求<br>  <strong>no-store：</strong>所有内容都不会被保存到缓存或Internet临时文件中<br>  <strong>max-age=delta-seconds：</strong>告知服务器希望接收一个存在时间不大于delta-seconds秒的资源<br>  <strong>max-stale[=delta-seconds]：</strong>告知服务器愿意接收一个超过缓存时间的资源，若没有设置delta-seconds表示任意超出时间<br>  <strong>min-fresh=delta-seconds：</strong>告知服务器希望接收一个在小于delta-seconds秒内更新过的资源<br>  <strong>no-transform：</strong>告知服务器希望获取的数据没有被转换（如压缩）<br>  <strong>only-if-cached：</strong>告知服务器希望获取缓存的内容，而不向原服务器发送请求<br>  <strong>cache-extension：</strong>自定义扩展值，若服务器不识别该值将被忽略</p>
</blockquote>
<p><strong>响应中的取值</strong></p>
<blockquote>
<p><strong>public：</strong>表明任何情况下都得缓存该资源（即使是需要http认证的资源）<br>  <strong>Private[=”field-name”]：</strong>表面报文中field-name（若没有设置则为全部）中的数据开放给某些用户（服务器指定的share-user，如代理服务器）做缓存使用，其他用户不能缓存这些数据<br>  <strong>no-cache：</strong>不直接使用缓存，要求向服务器发起请求<br>  <strong>no-store：</strong>所有内容都不会被保存到缓存或Internet临时文件中<br>  <strong>no-transform：</strong>告知客户端缓存文件时不得对实体数据做任何转换<br>  <strong>only-if-cached：</strong>告知（代理）服务器客户端希望获取缓存的内容，不向原服务器发送请求<br>  <strong>must-revalidate：</strong>当前资源一定是向原服务器发送验证请求的，若请求失败会返回504<br>  <strong>proxy-revalidate：</strong>与must-revalidate类似，指仅能用于共享缓存（如代理）<br>  <strong>max-age=delta-seconds：</strong>告知客户端该资源在delta-seconds秒内是新鲜的，无需向服务器发送请求<br>  <strong>s-maxage=delta-seconds：</strong>同max-age，但仅用于共享缓存<br>  <strong>cache-extension：</strong>自定义扩展值</p>
</blockquote>
<p>以上取值能组合起来使用，如：Cache-Control: max-age=3600, must-revalidate<br>组合的形式还能做一些浏览器行为不一致的兼容处理。例如在IE我们可以使用 no-cache 来防止点击“后退”按钮时页面资源从缓存加载，但在 Firefox 中，需要使用 no-store 才能防止历史回退时浏览器不从缓存中去读取数据，故我们在响应报头加上如下组合值即可做兼容处理：Cache-Control: no-cache, no-store</p>
<h3 id="http缓存策略"><a href="#http缓存策略" class="headerlink" title="http缓存策略"></a>http缓存策略</h3><h4 id="max-age与last-modified（if-modified-since）结合"><a href="#max-age与last-modified（if-modified-since）结合" class="headerlink" title="max-age与last-modified（if-modified-since）结合"></a>max-age与last-modified（if-modified-since）结合</h4><p><strong>1. 浏览器第一次请求资源</strong><br>1）浏览器查询无cache内容，发送请求到服务器<br>2）服务器接收到请求，响应并设置Cache-Control：max-age=XXX，Last-Modified：XXX GMT<br>3）浏览器接收到响应，展示内容并缓存响应内容（状态码为200 ok）<br><strong>2. 浏览器在max-age时间内请求资源</strong><br>浏览器查询有缓存，于是检查max-age，还未过期直接读取响应给用户（状态码为200 ok form XX cache）<br><strong>3. 浏览器在max-age时间外请求资源</strong><br>1）浏览器查询有缓存，于是检查max-age，发现已经过期，发现资源带有Last-Modified，于是在请求首部加上If-Modified-Since字段（值为），发送请求给服务器<br>2）服务器接收到请求发现有If-Modified-Since，于是和被请求资源的最后修改时间进行比较。若修改时间较新则返回新资源内容（状态码为200 ok）；若发现时间一致，则只返回状态码304 Not Modified而不带整个资源<br>3）浏览器接收到响应，根据响应状态选择是否使用缓存</p>
<h4 id="仅使用max-age"><a href="#仅使用max-age" class="headerlink" title="仅使用max-age"></a>仅使用max-age</h4><p>前两种情况和使用max-age和last-modified类似，服务器接收到请求后设置max-age，缓存过期后浏览器会再次向服务器发起请求</p>
<h4 id="max-age与ETag结合"><a href="#max-age与ETag结合" class="headerlink" title="max-age与ETag结合"></a>max-age与ETag结合</h4><p>前两种情况和使用max-age和last-modified类似，服务器接收到请求后设置max-age和ETag（由开发者自己确定的验证标识）<br>第三种：缓存过期后，发现资源带有ETag，于是在请求头中添加If-None-Match（和ETag值相同），发送请求给服务器，服务器收到请求后将If-None-Match的值与被请求资源的验证串进行对比。若不一致则返回新的资源（状态码200 ok）；若一致则只返回状态码304 Not Modified，不返回资源<br>浏览器接收到服务器的响应后，根据响应状态决定是否使用缓存</p>
<h3 id="浏览器缓存兼容及不同操作"><a href="#浏览器缓存兼容及不同操作" class="headerlink" title="浏览器缓存兼容及不同操作"></a>浏览器缓存兼容及不同操作</h3><p>参考<a href="http://blog.csdn.net/longxibendi/article/details/41630389" target="_blank" rel="external">浏览器缓存详解</a></p>
<p><strong>参考链接</strong></p>
<p><a href="http://blog.csdn.net/dinglang_2009/article/details/38142641" target="_blank" rel="external">cache策略实现原理</a><br><a href="http://www.cnblogs.com/cb0327/p/5400901.html" target="_blank" rel="external">浅谈浏览器http的缓存机制</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/05/16/浏览器9种缓存机制/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="fwp">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="fwp个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/05/16/浏览器9种缓存机制/" itemprop="url">浏览器9种缓存机制</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-05-16T14:46:21+08:00">
                2017-05-16
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/web/" itemprop="url" rel="index">
                    <span itemprop="name">web</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/05/16/浏览器9种缓存机制/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2017/05/16/浏览器9种缓存机制/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
             <span id="/2017/05/16/浏览器9种缓存机制/" class="leancloud_visitors" data-flag-title="浏览器9种缓存机制">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body han-init-context" itemprop="articleBody">

      
      

      
        
          
            <h3 id="一、http缓存"><a href="#一、http缓存" class="headerlink" title="一、http缓存"></a>一、http缓存</h3><p>http缓存是基于HTTP协议的浏览器文件级缓存机制。即针对文件的重复请求情况下，浏览器可以根据协议头判断从服务器端请求文件还是从本地读取文件，chrome控制台下的Frames即展示的是浏览器的http文件级缓存。<br>详细介绍请看<a href="https://www.zybuluo.com/mdeditor#809371" target="_blank" rel="external">http缓存机制</a></p>
<h3 id="二、websql"><a href="#二、websql" class="headerlink" title="二、websql"></a>二、websql</h3><p>Web Sql 数据库API实际上不是HTML5规范的组成部分，而是以一个独立规范形式出现，在HTML5之前就已经存在了。（现已不推荐使用）<br>其特点：</p>
<ul>
<li>将数据以数据库的形式存储在客户端，根据需求去读取;</li>
<li>与Storage的区别是：Storage和Cookie都是以键值对的形式存在的;</li>
<li>Web Sql 更方便于检索，允许sql语句查询;</li>
<li>这个数据库是集成在浏览器里面的，目前主流浏览器基本都已支持;<br><strong>websql API主要包含三个核心方法：</strong><ol>
<li>openDatabase：这个方法使用现有数据库或新建数据库来创建数据库对象</li>
<li>transaction：这个方法允许我们根据情况控制事务提交或回滚</li>
<li>executeSql：这个方法用于执行SQL语句</li>
</ol>
</li>
</ul>
<p>采用transaction和executeSql配合可以执行sql语句</p>
<pre><code> db.transaction(function (tx) { 
  tx.executeSql(&apos;CREATE TABLE IF NOT EXISTS t1 (id unique, log)&apos;);  
  tx.executeSql(&apos;INSERT INTO t1 (id, log) VALUES (1, &quot;foobar&quot;)&apos;);  
  tx.executeSql(&apos;INSERT INTO t1 (id, log) VALUES (2, &quot;logmsg&quot;)&apos;);  
});
</code></pre><h3 id="三、IndexedDB"><a href="#三、IndexedDB" class="headerlink" title="三、IndexedDB"></a>三、IndexedDB</h3><p>IndexedDB是一个事务型数据库系统，类似于基于SQL的RDBMS。 然而不同的是它使用固定列表，IndexedDB是一个基于JavaScript的面向对象的数据库。 IndexedDB允许您存储和检索用键索引的对象.<br>Web SQL Database实际上已经被废弃，而HTML5的支持的本地存储实际上变成了Web Storage（Local Storage和Session Storage）与IndexedDB。Web Storage使用简单字符串键值对在本地存储数据，方便灵活，但是对于大量结构化数据存储力不从心，IndexedDB是为了能够在客户端存储大量的结构化数据，并且使用索引高效检索的API。</p>
<h4 id="IndexedDB-API"><a href="#IndexedDB-API" class="headerlink" title="IndexedDB API"></a>IndexedDB API</h4><p>IndexedDB分别为同步和异步访问提供了单独的API。同步API本来是要用于仅供Web Workers内部使用，但是还没有被任何浏览器所实现。异步API在Web Workers内部和外部都可以使用。</p>
<h5 id="异步API"><a href="#异步API" class="headerlink" title="异步API"></a>异步API</h5><p><strong>操作数据库：</strong></p>
<ol>
<li>window.indexedDB.open(dbname, 版本号)-打开或创建一个数据库，该方法返回一个 IDBRequest 对象 (IDBOpenDBRequest)；异步操作通过在 IDBRequest 对象上触发事件来和调用程序进行通信。</li>
<li>所有异步请求都有一个 onsuccess 回调和一个 onerror 回调，前者在数据库操作成功时调用，后者在一个操作未成功时调用。</li>
<li>修改数据库或对象存储的代码必须位于 upgradeneeded 事件处理函数中；修改数据库会触发 upgradeneeded 事件（通过onupgradeneeded函数监听）。</li>
<li>删除数据库：indexDB.deleteDatabase(dbname)<br><strong>操作对象存储：</strong><br>对象存储是一个数据记录集合。要在现有数据库中创建一个新对象存储，则需要对现有数据库进行版本控制。为此，请打开要进行版本控制的数据库。除了数据库名称之外，open 方法还接受版本号作为第二个参数。</li>
<li>创建对象存储：createObjectStore(name, option)</li>
<li>操作对象：添加-IDBObjectStore.add()；获取-IDBObjectStore.get()；删除-IDBObjectStore.delete()；更新-IDBObjectStore.put()等</li>
<li>关于索引：创建-IDBObjectStore.createIndex()；打开-IDBObjectStore.index()；删除-IDBObjectStore.deleteIndex()；</li>
<li>关于游标：IDBObjectStore.openCursor()；IDBObjectStore.openKeyCursor() </li>
<li><p>使用事务：db.transaction(objectname, mode)，默认mode是readonly，其余选项还有readwrite和versionchange，示例代码：</p>
<p> var trans1 = db.transaction(“foo”, “readwrite”);<br> var trans2 = db.transaction(“foo”, “readwrite”);<br> var objectStore2 = trans2.objectStore(“foo”)<br> var objectStore1 = trans1.objectStore(“foo”)<br> objectStore2.put(“2”, “key”);<br> objectStore1.put(“1”, “key”);</p>
</li>
</ol>
<h3 id="四、localStorage"><a href="#四、localStorage" class="headerlink" title="四、localStorage"></a>四、localStorage</h3><p>localStorage是html5的一种新的本地缓存方案，目前用的比较多，一般用来存储ajax返回的数据，加快下次页面打开时的渲染速度。<br>无时间限制，但不能存大量数据；数据量超过存储范围会报错且自动删除靠前的数据。<br>localStorage.setItem(key, value)<br>localStorage.getItem(key)<br>localStorage.removeItem(key)<br>localStorage.clear()</p>
<h3 id="五、sessionStorage"><a href="#五、sessionStorage" class="headerlink" title="五、sessionStorage"></a>五、sessionStorage</h3><p>sessionStorage和localstorage类似，但是浏览器关闭则会全部删除，api和localstorage相同。</p>
<h3 id="六、application-cache"><a href="#六、application-cache" class="headerlink" title="六、application cache"></a>六、application cache</h3><p>HTML5 引入了应用程序缓存，这意味着web应用可进行缓存，并可在没有因特网连接时进行访问。<br><strong>三个优势：</strong><br>离线浏览 - 用户可在应用离线时使用它们<br>速度 - 已缓存资源加载得更快<br>减少服务器负载 - 浏览器将只从服务器下载更新过或更改过的资源。<br>所有主流浏览器均支持应用程序缓存，除了 IE。</p>
<h4 id="使用应用程序缓存"><a href="#使用应用程序缓存" class="headerlink" title="使用应用程序缓存"></a>使用应用程序缓存</h4><p>要在html标签上加上mainfest属性</p>
<pre><code>&lt;!DOCTYPE HTML&gt;
&lt;html manifest=&quot;demo.appcache&quot;&gt;
...
&lt;/html&gt;
</code></pre><p>以下是demo.appcache文件的一个示例</p>
<pre><code>CACHE MANIFEST      //文件将在首次下载后进行缓存
# 2012-02-21 v1.0.0
/theme.css
/logo.gif
/main.js

NETWORK:        //文件需要与服务器的连接，且不会被缓存
login.asp

FALLBACK:       //文件规定当页面无法访问时的回退页面
//第一个 URI 是资源，第二个是替补
/html5/ /404.html
</code></pre><h3 id="七、cachestorage"><a href="#七、cachestorage" class="headerlink" title="七、cachestorage"></a>七、cachestorage</h3><p>CacheStorage是在ServiceWorker的规范中定义的。它主要用来存储 Response 对象，即是对 HTTP 响应做缓存的。<br>CacheStorage 是多个 Cache 的集合，而每个 Cache 可以存储多个 Response 对象。</p>
<h4 id="主要API"><a href="#主要API" class="headerlink" title="主要API"></a>主要API</h4><ol>
<li>CacheStorage.match() - 判断是否和cache中某个对象匹配，若匹配则返回一个Promise对象</li>
<li>cacheStorage.has() - 如果包含指定cache对象，则返回一个promise对象。</li>
<li>cacheStorage.open() - 打开一个cache对象，成功则返回一个promise对象。</li>
<li>cacheStorage.delete() - 删除cache对象，成功则返回一个promise对象，否则返回false。</li>
<li>cacheStorage.keys() - </li>
<li>cache.addAll(), cache.put()<h3 id="八、cookie"><a href="#八、cookie" class="headerlink" title="八、cookie"></a>八、cookie</h3>服务器端设置cookie向客户端颁发，cookie一般通过http请求中在头部一起发送到服务器端。<br>一条cookie记录主要由键、值、域、过期时间、大小组成，一般保存用户的认证信息。cookie最大长度和域名个数由不同浏览器决定。<br>可能会受到CSRF／XSRF（Cross-site request forgery）攻击<h3 id="九、flash缓存"><a href="#九、flash缓存" class="headerlink" title="九、flash缓存"></a>九、flash缓存</h3>这种方式基本不用，这一方法主要基于flash有读写浏览器端本地目录的功能，同时也可以向js提供调用的api，则页面可以通过js调用flash去读写特定的磁盘目录，达到本地数据缓存的目的。</li>
</ol>
<p>参考：<br><a href="http://www.techweb.com.cn/network/system/2016-01-05/2252395.shtml" target="_blank" rel="external">浏览器九种缓存机制介绍</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.jpg"
               alt="fwp" />
          <p class="site-author-name" itemprop="name">fwp</p>
           
              <p class="site-description motion-element" itemprop="description">知识记录</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">30</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">8</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">17</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">fwp</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.2"></script>



  
    <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  

    
      <script id="dsq-count-scr" src="https://fuweiping.disqus.com/count.js" async></script>
    

    

  




	





  








  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.4.js"></script>
  <script>AV.initialize("3XB8AXsRovxBiBFseXLXlKNq-gzGzoHsz", "S51B3iUah1f5XHWzRVLEcYqW");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  

  

  

  

</body>
</html>
